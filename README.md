# 1 
-top 명령어는 리눅스와 유닉스 기반 시스템에서 사용되는 유틸리티 중 하나로, 시스템의 현재 상태를 모니터링하고 프로세스의 활동을 실시간으로 확인하는 데 사용됩니다. 주로 시스템 리소스 사용량을 파악하거나 프로세스들의 실행 상태를 추적할 때 유용합니다. 일반적으로 top 명령어를 실행하면 CPU 사용량, 메모리 사용량, 스왑 메모리 사용량, 프로세스 수 등 시스템의 기본적인 정보를 화면에 표시합니다. 또한 프로세스들을 CPU 사용량이나 메모리 사용량 등의 기준으로 정렬하여 보여줍니다.
top 명령어를 사용하면서 몇 가지 유용한 키 조합을 사용할 수 있습니다. 일반적으로 사용되는 몇 가지 키는 다음과 같습니다.
예시:
q: top 명령어를 종료합니다.
Space: 화면을 새로 고침합니다.
k: 프로세스를 종료합니다. 종료할 프로세스의 PID를 입력하라는 프롬프트가 나타납니다.
u: 특정 사용자가 시작한 프로세스만 표시합니다. 사용자 이름을 입력하라는 프롬프트가 나타납니다.
M: 메모리 사용량에 따라 프로세스를 정렬합니다.
P: CPU 사용량에 따라 프로세스를 정렬합니다.
T: 프로세스가 실행한 시간에 따라 정렬합니다.
이 외에도 다양한 옵션이 있으며, man top 명령어를 사용하여 자세한 정보를 얻을 수 있습니다.

지금부터는 top 명령어의 디테일 영역에 대해서 알아보도록 하겠습니다. 디테일 영역에는 각 프로세스에 대한 상세한 내용이 나옵니다. 아래의 이미지 부분이 디테일 부분인데요, 각 요소에 대해서 하나씩 보도록하겠습니다.
![다운로드](https://github.com/20243069/-/assets/171208901/0c274478-3a68-4fab-80f2-2ac5fa72c4bd)
#PID
PID는 프로세스 ID이며 프로세스를 구분하기 위한 겹치지않는 고유한 값입니다.
#USER
해당 프로세스를 실행한 USER 이름 또는 효과를 받는 USER의 이름입니다.
#PR & NI
PR : 커널에 의해서 스케줄링되는 우선순위입니다.
NI : PR에 영향을 주는 nice라는 값입니다.
#VIRT, RES, SHR, %MEM
해당 필드들은 프로세스의 메모리와 관련있습니다.
VIRT : 프로세스가 소비하고 있는 총 메모리입니다. 프로그램이 실행중인 코드, heap, stack과 같은 메모리, IO buffer 메모리를 포함합니다.
RES : RAM에서 사용중인 메모리의 크기를 나타냅니다.
SHR : 다른 프로세스와의 공유메모리(Shared Memory)를 나타냅니다.
%MEM : RAM에서 RES가 차지하는 비율을 나타냅니다.
#S 
S는 프로세스의 현재 상태를 나타냅니다.
#TIME+ 
TIME+는 프로세스가 사용한 토탈 CPU 시간
#COMMAND
COMMAND는 해당 프로세스를 실행한 커맨드를 나타냅니다.

# 2
-ps 명령어는 리눅스와 유닉스 시스템에서 현재 실행 중인 프로세스에 대한 정보를 보여주는 유틸리티입니다.
기본적으로 ps 명령어를 실행하면 현재 로그인한 사용자의 프로세스만 표시됩니다. 일반적으로는 프로세스의 PID (프로세스 식별자), CPU 사용량, 메모리 사용량, 실행 시간 등의 정보를 표시합니다.
ps 명령어에는 여러 옵션이 있으며, 다양한 형식으로 출력하거나 특정 조건에 맞는 프로세스만 필터링하여 보여줄 수 있습니다. 일반적으로 사용되는 ps 명령어의 몇 가지 옵션은 다음과 같습니다
예시:
a: 현재 터미널과 관계없이 모든 사용자의 프로세스를 표시합니다.
u: 사용자 관련 정보를 보여줍니다. (사용자 이름, CPU 및 메모리 사용량 등)
x: 터미널에 연결되지 않은 프로세스도 표시합니다.
e: 모든 프로세스를 표시합니다.
f: 프로세스 간의 부모-자식 관계를 표시합니다.
예를 들어, ps aux 명령어는 모든 사용자의 모든 프로세스를 자세히 보여줍니다. 이 외에도 다양한 옵션을 통해 원하는 정보를 얻을 수 있습니다. 
다음으로는 사용 예시를 보여드리겠습니다.
1.
![ps_ef](https://github.com/20243069/-/assets/171208901/8a541a09-c60f-4b1d-a788-f83e8c2b0ca7)
-ef 옵션은 동작 중인 모든 프로세스를 소유자 정보와 함께 풀 포맷으로 출력하는 명령어입니다.

2.
![ps_aux](https://github.com/20243069/-/assets/171208901/629ebf13-3d3d-4ac6-b0ba-95f42dd894af)
aux는 동작 중인 모든 프로세스를 소유자 정보와 함께 다양한 정보를 출력하는 옵션입니다.

3.
![ps_-el](https://github.com/20243069/-/assets/171208901/82584f7f-2337-41b8-b100-91383eda4a64)
-el 옵션은 프로세스의 정보가 긴 포맷으로 출력됩니다. -ef 옵션에서 보지 못한 F, S, PRI, NI 등 다양한 정보가 출력됩니다.

이외에도 ps명령어를 활용한 많은 예시가 있는데 더 자세한 내용은 man ps 명령어를 통해 확인할 수 있습니다.

# 3
-jobs 명령어는 쉘(shell)에서 실행 중인 작업(job)에 대한 정보를 보여주는 명령어입니다. 쉘은 보통 여러 개의 작업을 관리하며, 이 작업은 백그라운드에서 실행되거나 포그라운드에서 실행될 수 있습니다.
일반적으로 jobs 명령어는 다음과 같은 정보를 제공합니다.
작업 번호(Job Number)
작업 상태(Job Status)
작업 ID(Job ID)
작업의 명령(Command) 또는 프로세스 이름(Process Name)
작업 번호는 백그라운드에서 실행 중인 작업을 식별하는 데 사용됩니다. 작업 상태는 해당 작업이 실행 중인지, 일시 중지되었는지 등을 나타냅니다. 작업 ID는 각 작업에 할당된 고유한 식별자입니다.
일반적으로 jobs 명령어는 현재 쉘 세션에서 실행 중인 작업들을 보여줍니다. 일시 중지된 작업이나 백그라운드에서 실행 중인 작업 등을 확인할 수 있습니다.
jobs 명령어에서 사용할 수 있는 주요한 옵션들은 다음과 같습니다.
-l 옵션: 프로세스 ID와 함께 잡 목록을 출력합니다.
-n 옵션: 마지막로 알림 이후 변경된 잡만 출력합니다.
-p 옵션: 잡의 프로세스 ID만 출력합니다.
-r 옵션: 실행 중인 잡만 출력합니다.
-s 옵션: 중지된 잡만 출력합니다.

# 4
-kill 명령어는 리눅스와 유닉스 기반 시스템에서 프로세스를 종료하는 데 사용되는 명령어입니다. 프로세스를 강제로 종료하거나 시그널을 보내어 특정 작업을 실행할 수 있습니다.
kill 명령어는 다음과 같은 형식을 가집니다.
kill [옵션] [PID]
옵션(Option): kill 명령어는 여러 옵션을 지원합니다. 가장 일반적으로 사용되는 옵션은 -9 또는 SIGKILL 옵션으로, 이 옵션을 사용하면 프로세스를 강제로 종료할 수 있습니다. 그 외에도 -15 또는 SIGTERM 옵션을 사용하여 프로세스에 종료 신호를 보낼 수 있습니다.
PID(Process ID): 종료하려는 프로세스의 ID를 지정합니다.
 kill 명령어에는 다양한 옵션을 사용할 수 있습니다. 몇 가지 유용한 옵션을 살펴보겠습니다:
-s <signal>: 특정 시그널(signal)을 사용하여 프로세스를 종료합니다. 기본적으로 SIGTERM 시그널이 사용됩니다.
-l, --list: 지원되는 시그널(signal) 목록을 출력합니다.
-a, --all: 현재 사용자에 속한 모든 프로세스를 종료합니다.
-q, --queue: 프로세스에 시그널을 보내는 대신 시그널을 대기열에 추가합니다.
예시로 -l 명령어를 사용하면 아래사진과 같은 결과가 나오면서 사용 가능한 모든 신호(Signal)를 확인하실 수 있습니다.
![캡처](https://github.com/20243069/-/assets/171208901/a4c4e823-f173-4f72-92d8-5b0ea25efbdc)

이처럼 리눅스 명령어들은 제가 조사한 top, ps, jobs, kill 이외에도 굉장히 많은 명령어들이 있습니다. 이렇게 다양한 명령어들을 배우고 익숙해진다면 우리도 리눅스를 이용해 시스템을 관리하고 개발하는 데 도움이 됩니다.




